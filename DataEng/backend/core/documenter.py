import os
from typing import Dict, Optional

class Documenter:
    """
    Handles the generation of project documentation, specifically architecture diagrams
    and technical overviews based on the chosen technology stack.
    """
    def __init__(self, output_dir: str):
        self.output_dir = output_dir

    def generate_architecture_doc(self, stack: Dict[str, str]) -> str:
        """
        Generates an ARCHITECTURE.md file with a Mermaid.js diagram and detailed
        component descriptions based on the stack.
        
        Args:
            stack: A dictionary configuration of the stack (e.g., {'ingestion': 'Airbyte', ...})
            
        Returns:
            The absolute path to the generated ARCHITECTURE.md file.
        """
        diagram = self._generate_mermaid_diagram(stack)
        
        file_path = os.path.join(self.output_dir, "ARCHITECTURE.md")
        with open(file_path, "w", encoding="utf-8") as f:
            # Header
            f.write("# System Architecture\n\n")
            f.write("> **Note:** This document is automatically generated by the Antigravity Documenter module. ")
            f.write("It serves as a living document of the system's architecture.\n\n")

            # Executive Summary
            f.write("## Executive Summary\n\n")
            f.write("This data platform is architected to provide a robust, scalable flow from raw data sources ")
            f.write("to actionable business intelligence. The architecture follows a modern data stack pattern, ")
            f.write("ensuring modularity and maintainability.\n\n")

            # Stack Configuration (Table)
            f.write("## Technology Stack\n\n")
            f.write("| Component | Technology | Description |\n")
            f.write("|-----------|------------|-------------|\n")
            for category, tool in stack.items():
                if tool:
                    desc = self._get_component_description(category, tool)
                    f.write(f"| {category.title()} | **{tool}** | {desc} |\n")
            f.write("\n")

            # Diagram
            f.write("## Data Flow Architecture\n\n")
            f.write("The following diagram visualizes the end-to-end data lineage:\n\n")
            f.write("```mermaid\n")
            f.write(diagram)
            f.write("\n```\n\n")
            
            # Component Details
            f.write("## Component Interactions\n\n")
            self._write_component_details(f, stack)
                    
        return file_path

    def _generate_mermaid_diagram(self, stack: Dict[str, str]) -> str:
        """
        Constructs the Mermaid.js graph definition.
        """
        lines = ["graph TD"]
        
        # Styles
        lines.append("    %% Styles")
        lines.append("    classDef db fill:#e1f5fe,stroke:#01579b,stroke-width:2px,color:#000;")
        lines.append("    classDef process fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px,color:#000;")
        lines.append("    classDef source fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px,color:#000;")
        lines.append("    classDef bi fill:#fff3e0,stroke:#e65100,stroke-width:2px,color:#000;")
        
        stack_map = {k.lower(): v for k, v in stack.items() if v}

        # Nodes
        previous_node = "Source"
        lines.append(f"    {previous_node}[Raw Data Sources]:::source")
        
        # 1. Ingestion
        if "ingestion" in stack_map:
            name = stack_map["ingestion"]
            node_id = "Ingestion"
            lines.append(f"    {node_id}[{name}]:::process")
            lines.append(f"    {previous_node} -->|Extract & Load| {node_id}")
            previous_node = node_id
            
        # 2. Storage
        if "storage" in stack_map:
            name = stack_map["storage"]
            node_id = "Storage"
            lines.append(f"    {node_id}[({name})]:::db")
            lines.append(f"    {previous_node} -->|Raw Data| {node_id}")
            previous_node = node_id
            
        # 3. Transformation
        if "transformation" in stack_map:
            name = stack_map["transformation"]
            node_id = "Transformation"
            lines.append(f"    {node_id}[{name}]:::process")
            lines.append(f"    {previous_node} -->|Transform| {node_id}")
            previous_node = node_id
            
        # 4. BI
        if "bi" in stack_map:
            name = stack_map["bi"]
            node_id = "BI"
            lines.append(f"    {node_id}[{name}]:::bi")
            lines.append(f"    {previous_node} -->|Visualize| {node_id}")
            previous_node = node_id

        # Orchestration
        if "orchestration" in stack_map:
            name = stack_map["orchestration"]
            orch_id = "Orchestrator"
            lines.append(f"    {orch_id}{{{name}}}")
            
            if "ingestion" in stack_map:
                lines.append(f"    {orch_id} -.->|Trigger| Ingestion")
            if "transformation" in stack_map:
                lines.append(f"    {orch_id} -.->|Schedule| Transformation")

        return "\n".join(lines)

    def _get_component_description(self, category: str, tool: str) -> str:
        # Simple dictionary for descriptions, can be expanded
        descriptions = {
            "ingestion": "Responsible for extracting data from sources and loading it into storage.",
            "storage": "Centralized repository for raw and transformed data.",
            "transformation": "Applies business logic to clean, aggregate, and model data.",
            "bi": "Provides dashboards and analytics for business decision making.",
            "orchestration": "Manages the workflow execution and dependency resolution."
        }
        return descriptions.get(category.lower(), "Core component of the architecture.")
        
    def _write_component_details(self, f, stack: Dict[str, str]):
        stack_map = {k.lower(): v for k, v in stack.items() if v}
        
        if "ingestion" in stack_map and "storage" in stack_map:
            f.write("### Data Ingestion\n")
            f.write(f"{stack_map['ingestion']} is configured to pull data from configured sources ")
            f.write(f"and land it into {stack_map['storage']}. Sync frequency and schema mapping are managed here.\n\n")
            
        if "transformation" in stack_map:
            f.write("### Data Transformation\n")
            f.write(f"{stack_map['transformation']} handles the ELT process, taking raw data from {stack_map.get('storage', 'storage')} ")
            f.write("and applying SQL/Python models to produce analytics-ready tables.\n\n")
